OAuth 1.5
--

This document is incomplete.

Basics
--

### There are applications which have API keys

* Keys are used for identifying apps and doing rate-limiting

### Every application has a unique (master) signing secret.

* Secret secret is secret.

### Every application may have (n) "grasshopper" keys (and corresponding secrets)

* They have a strictly enforced upper limit TTL

* They are optional – an app developer may choose to disable them entirely

* They can not be renewed

* They have restricted access to API methods – they can not be used to mint a persistent token, for example

* They are deleted if and when their "master" application/API key is deleted

### There are three classes of "blessing" an API method, each building on its predecessor:

* An API key

* Signed with an application's secret

* Signed with an application's and user's secret

_API signatures are discussed below._

### There are access tokens (or "auth" tokens) which bind a user to an application.

* Each access tokens has a unique signing secret. 

* Each access token may be restricted by permissions (read, write, etc) as defined by the user
    
* Each access token may be enforced by a TTL, defined by the user or the server (in the case of JS apps)

### Signatures are generated by hashing all the request parameters using the application secret or grasshopper secret

* Signatures are further hashed using the user secret if the request is meant to be "authed"

* Something about binary/multipart uploads and md5sum...

Persistent access tokens
--

# Persistent access tokens are minted using the basic frob-token dance

_TO DO: formatting, etc._

* Clients request frob; frob has a TTL; client sends frob in auth URL for user; frob is de facto CSRF crumb; frob loves you

* Server returns frob to a fixed callback URL stored on the server; client requests token (for frob) <-- negating the absolute requirement for SSL in token exchange

Short-lived access tokens (or "stateless" applications (or "single-page JS" applications))
--

### One page JS apps would initialize themselves by requesting a grasshopper key/secret and an access token from a discrete endpoint (say /oauth-1.5/grasshopper)

* This endpoint is controlled by a feature flag; not required to be implemented

* Everything must be done over SSL

* The client must pass a CSRF crumb which the server will parrot back

* Once authed by the user, returns a TTL grasshopper secret (for the API key) and a TTL access token for the user

* All subsequent API requests are signed as usual (see below)
