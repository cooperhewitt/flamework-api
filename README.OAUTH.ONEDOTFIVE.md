OAuth 1.5
--

This document is incomplete.

Applications
--

### There are applications which have API keys

* Keys are used for identifying apps and doing rate-limiting

### Every application has a unique (master) signing secret.

* Secret secret is secret.

### Every application may have (n) "grasshopper" keys (and corresponding secrets)

These are designed for use with "stateless" applications, described in detail below.

* They have a upper-limit time-to-live (TTL) that is strictly enforced by the server.

* They are optional – an app developer may choose to disable them entirely.

* They can not be renewed.

* They have restricted access to API methods – they can not be used to mint a persistent token, for example.

* They are deleted if and when their "master" application/API key is deleted.

### There are three classes of "blessing" an API method, each building on its predecessor:

* An API key

* Signed with an application's secret

* Signed with an application's and user's secret

_API signatures are discussed below._

Tokens
--

### Access tokens

Access tokens (or "auth" tokens) bind a user to an application.

* Each access tokens has a unique signing secret. 

* Each access token may be restricted by permissions (read, write, etc) as defined by the user
    
* Each access token may be enforced by a TTL, defined by the user or the server (in the case of JS apps)

### Grant tokens

Sometimes called "frobs".

TBW

Persistent access tokens
--

Persistent access tokens are minted using the basic frob-token dance

_TO DO: formatting, etc._

* Clients request frob; frob has a TTL; client sends frob in auth URL for user; frob is de facto CSRF crumb; frob loves you

* Server returns frob to a fixed callback URL stored on the server; client requests token (for frob) <-- negating the absolute requirement for SSL in token exchange

Short-lived access tokens
--

Or: "stateless" applications (or "single-page JS" applications)

* This endpoint is controlled by a feature flag; not required to be implemented

* Everything must be done over SSL

* Redirect URLs are defined using a fixed list on the server.

* Applications are assigned a unique `appid` which is generated by the server and must be passed with the initial request – the appid might just be something the master API key and the redirect URL concatenated and hashed.

* The server must **always** display an interstitial page prompting the logged in user to approve the request. There are no automagic redirects for keys/tokens that have already been approved but not yet expired.

* Once authed by the user, the server will return a grasshopper key/secret and an access token/secret (remember both are time-sensitive) for the user (to the predefined redirect URL)

* All subsequent API requests are signed as usual (see below)

TO DO: example(s)

Signatures
--

### Signatures are generated by hashing all the request parameters using the application secret or grasshopper secret

* Signatures are further hashed using the user secret if the request is meant to be "authed"

* SHA256 / HMAC

* Something about binary/multipart uploads and md5sum...
