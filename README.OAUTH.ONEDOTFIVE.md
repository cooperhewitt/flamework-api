OAuth 1.5
--

This document is incomplete. Also don't get hung up on all the talk of "grasshoppers". It's just a place-holder while this is all being fleshed out.

Applications
--

### There are applications which have API keys

* Keys are used for identifying apps and doing rate-limiting

### Every application has a unique (master) signing secret.

* Secret secret is secret.

### Every application may have (n) "grasshopper" keys (and corresponding secrets)

These are designed for use with "stateless" applications, described in detail below.

* They have a upper-limit time-to-live (TTL) that is strictly enforced by the server.

* They are optional – an app developer may choose to disable them entirely.

* They can not be renewed.

* They have restricted access to API methods – they can not be used to mint a persistent token, for example.

* They are deleted if and when their "master" application/API key is deleted.

### There are three classes of "blessing" an API method, each building on its predecessor:

* An API key

* Signed with an application's secret

* Signed with an application's and user's secret

_API signatures are discussed below._

Tokens
--

### Access tokens

Access tokens (or "auth" tokens) bind a user to an application.

* Each access tokens has a unique signing secret. 

* Each access token may be restricted by permissions (read, write, etc) as defined by the user
    
* Each access token may be enforced by a TTL, defined by the user or the server (in the case of JS apps)

### Grant tokens

Sometimes called "frobs".

TBW

Persistent access tokens
--

Persistent access tokens are minted using the basic frob-token dance

_TO DO: formatting, etc._

* Clients request frob; frob has a TTL; client sends frob in auth URL for user; frob is de facto CSRF crumb; frob loves you

* Server returns frob to a fixed callback URL stored on the server; client requests token (for frob) <-- negating the absolute requirement for SSL in token exchange

Short-lived access tokens
--

Or: "stateless" applications (or "single-page JS" applications)

* Not required to be implemented. This is helper glue for stateless applications.
 
* Functions only as a way for stateless apps to retrieve a TTL-restricted grasshopper key and TTL-restricted auth token using a separate endpoint, like `/oauth1.5/grasshopper/'

* Everything must be done over SSL

* Redirect URLs are defined using a fixed list on the server.

* Applications are assigned a unique `appid` which is generated by the server and must be passed with the initial request – the appid might just be something the master API key and the redirect URL concatenated and hashed.

* The server must **always** display an interstitial page prompting the logged in user to approve the request. There are no automagic redirects for keys/tokens that have already been approved but not yet expired.

* Once authed by the user, the server will return a grasshopper key/secret and an access token/secret (remember both are time-sensitive) for the user (to the predefined redirect URL)

* All subsequent API requests are signed as usual (see below)

TO DO: example(s)

Signatures
--

### Signatures are generated by hashing all the request parameters using the application secret or grasshopper secret

* Signatures are further hashed using the user secret if the request is meant to be "authed"

* SHA256 / HMAC

* Something about binary/multipart uploads and md5sum...

SSL and HTTPS
--

Unless otherwise noted the use of encrypted connections for API requests is encouraged but not required.

Crazy talk???
--

Maybe, yes. Go read [this essay on (the impossibility of) Javascript cryptography](http://www.matasano.com/articles/javascript-cryptography/). Everything the author says is true.

The "grasshopper" keys/secrets are, ultimately, a lot of busy work to preserve the semantics of the signing process and to a lesser degree the roles in delegated auth: that there is a service, an application and a user.

It also has to be done over SSL for all the reasons that the author cites.

At which point it is perfectly reasonable to ask: Why not just use the access token delivered to the browser, per the spec? Especially if it meant to have a fixed TTL.

But then you're in a position where have to embrace the same semantics (a single master token) for not-single-page-javascript applications.

Or you end up having to choose one or the other and/or modify the server side of things to account for multiple types of authentication or authorization.

I still think that signed request and shared secrets is a good model.

For starters, it means that leaking a single URL doesn't compromise everything else and doesn't mean that you need to promote things like passing around tokens in auth headers as a preventative. Hypermedia keeners aside the auth-in-header thing smacks of a clumsy work around to the problem of parameter based method calls and someone forgetting to type the "s" at the end of https.

So, yes. It's absolutely extra work for JS people and introduces extra dependencies, namely the crypto code to do SHA-256 (or whatever).

And all of the risks around even temporary signing secrets leaking in a JS context are real and valid. Thus the temporary nature of the secrets and the part where they need to be enabled by a developer explicitly. 
